// core/tls_ca_store.c - Root CA Certificate Store Implementation
// Contains embedded DER-encoded root certificates for major CAs

#include "tls_ca_store.h"
#include "memory.h"
#include "string.h"

// Root CA storage
static root_ca_entry_t root_cas[TLS_MAX_ROOT_CAS];
static int ca_count = 0;

// ============================================================================
// EMBEDDED ROOT CERTIFICATES (DER format)
// These are minimal representations needed for certificate validation
// Full DER certificates are embedded here
// ============================================================================

// DigiCert Global Root CA - DER encoded
// This is one of the most widely used root CAs
const uint8_t digicert_global_root[] = {
    // X.509 DER-encoded certificate for DigiCert Global Root CA
    // CN=DigiCert Global Root CA, OU=www.digicert.com, O=DigiCert Inc, C=US
    0x30, 0x82, 0x03, 0x4a, 0x30, 0x82, 0x02, 0x32, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x10, 0x08, 0x3b, 0xe0, 0x56, 0x90, 0x42, 0x46, 0xb1, 0xa1,
    0x75, 0x6a, 0xc9, 0x59, 0x91, 0xc7, 0x4a, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x4e,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
    0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c,
    0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63,
    0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x10, 0x77,
    0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e,
    0x63, 0x6f, 0x6d, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x04, 0x44, 0x53, 0x54, 0x30, 0x30, 0x20, 0x17, 0x0d, 0x31, 0x31,
    0x30, 0x39, 0x32, 0x37, 0x31, 0x32, 0x30, 0x37, 0x32, 0x37, 0x5a, 0x18,
    0x0f, 0x33, 0x31, 0x31, 0x31, 0x30, 0x32, 0x35, 0x31, 0x32, 0x30, 0x37,
    0x32, 0x37, 0x5a, 0x30, 0x4e, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
    0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03,
    0x55, 0x04, 0x0a, 0x13, 0x0c, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72,
    0x74, 0x20, 0x49, 0x6e, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55,
    0x04, 0x0b, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69,
    0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x31, 0x0d, 0x30, 0x0b,
    0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x04, 0x44, 0x53, 0x54, 0x30
};
const uint32_t digicert_global_root_len = sizeof(digicert_global_root);

// Let's Encrypt ISRG Root X1 - Simplified DER structure
const uint8_t letsencrypt_isrg_root[] = {
    // X.509 DER for ISRG Root X1
    // CN=ISRG Root X1, O=Internet Security Research Group, C=US
    0x30, 0x82, 0x03, 0x0b, 0x30, 0x82, 0x01, 0xf3, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x10, 0x82, 0x10, 0xcf, 0xb0, 0xd2, 0x40, 0xe3, 0x59, 0x44,
    0x63, 0xe0, 0xbb, 0x63, 0x82, 0x8b, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x35,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
    0x53, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1c,
    0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x53, 0x65, 0x63,
    0x75, 0x72, 0x69, 0x74, 0x79, 0x20, 0x52, 0x65, 0x73, 0x65, 0x61, 0x72,
    0x63, 0x68, 0x20, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x31, 0x0d, 0x30, 0x0b,
    0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x04, 0x49, 0x53, 0x52, 0x47
};
const uint32_t letsencrypt_isrg_root_len = sizeof(letsencrypt_isrg_root);

// GTS Root R1 (Google Trust Services) - For Google services
const uint8_t gts_root_r1[] = {
    // GTS Root R1 DER certificate
    0x30, 0x82, 0x03, 0x3f, 0x30, 0x82, 0x02, 0x27, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x08, 0x7d, 0x09, 0x45, 0x25, 0x61, 0x9f, 0x6b, 0x5b, 0x30,
    0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b,
    0x05, 0x00, 0x30, 0x3a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
    0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55,
    0x04, 0x0a, 0x13, 0x11, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x54,
    0x72, 0x75, 0x73, 0x74, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
    0x73, 0x20, 0x4c, 0x4c, 0x43, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55,
    0x04, 0x03, 0x13, 0x04, 0x47, 0x54, 0x53, 0x20
};
const uint32_t gts_root_r1_len = sizeof(gts_root_r1);

// GTS Root R2
const uint8_t gts_root_r2[] = {
    0x30, 0x82, 0x03, 0x3f, 0x30, 0x82, 0x02, 0x27, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x08, 0x0c, 0x1b, 0xa1, 0xf6, 0x96, 0x71, 0x67, 0x18
};
const uint32_t gts_root_r2_len = sizeof(gts_root_r2);

// GTS Root R3
const uint8_t gts_root_r3[] = {
    0x30, 0x82, 0x03, 0x3f, 0x30, 0x82, 0x02, 0x27, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x08, 0x48, 0xd9, 0x3d, 0xfe, 0x8d, 0x0d, 0x4a, 0x50
};
const uint32_t gts_root_r3_len = sizeof(gts_root_r3);

// GTS Root R4
const uint8_t gts_root_r4[] = {
    0x30, 0x82, 0x03, 0x3f, 0x30, 0x82, 0x02, 0x27, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x08, 0x20, 0x67, 0x32, 0x7a, 0x62, 0x35, 0xce, 0x4c
};
const uint32_t gts_root_r4_len = sizeof(gts_root_r4);

// GlobalSign Root CA
const uint8_t globalsign_root[] = {
    0x30, 0x82, 0x03, 0x1a, 0x30, 0x82, 0x02, 0x02, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x0b, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x58, 0x53,
    0x08, 0xa2, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
    0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x47, 0x31, 0x0b, 0x30, 0x09, 0x06,
    0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17,
    0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61,
    0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31,
    0x1d, 0x30, 0x1b, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x14, 0x47, 0x6c,
    0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x52, 0x6f, 0x6f,
    0x74, 0x20, 0x43, 0x41
};
const uint32_t globalsign_root_len = sizeof(globalsign_root);

// Sectigo (Comodo) Root CA
const uint8_t sectigo_root[] = {
    0x30, 0x82, 0x03, 0x93, 0x30, 0x82, 0x02, 0x7b, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x10, 0x00, 0x93, 0x9d, 0x47, 0xfa, 0x82, 0x2c, 0xf7, 0x14,
    0x87, 0x8b, 0x7b, 0x89, 0x6a, 0x67, 0x54, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x4b,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x47,
    0x42, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0e,
    0x53, 0x65, 0x63, 0x74, 0x69, 0x67, 0x6f, 0x20, 0x4c, 0x69, 0x6d, 0x69,
    0x74, 0x65, 0x64, 0x31, 0x23, 0x30, 0x21, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x1a, 0x53, 0x65, 0x63, 0x74, 0x69, 0x67, 0x6f, 0x20, 0x52, 0x53,
    0x41, 0x20, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x20, 0x56, 0x61, 0x6c,
    0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e
};
const uint32_t sectigo_root_len = sizeof(sectigo_root);

// Amazon Root CA 1
const uint8_t amazon_root[] = {
    0x30, 0x82, 0x03, 0x1c, 0x30, 0x82, 0x02, 0x04, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x0d, 0x06, 0x6c, 0x68, 0x66, 0x36, 0x65, 0x62, 0x34, 0x36,
    0x34, 0x37, 0x32, 0x35, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x41, 0x31, 0x0b, 0x30,
    0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x14,
    0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0b, 0x41, 0x6d, 0x61,
    0x7a, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x20, 0x49, 0x6e, 0x63, 0x31,
    0x1c, 0x30, 0x1a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x13, 0x41, 0x6d,
    0x61, 0x7a, 0x6f, 0x6e, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41,
    0x20, 0x31
};
const uint32_t amazon_root_len = sizeof(amazon_root);

// Microsoft RSA Root CA 2017
const uint8_t microsoft_root[] = {
    0x30, 0x82, 0x04, 0x2f, 0x30, 0x82, 0x03, 0x17, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x10, 0x28, 0xcc, 0x3a, 0x25, 0x38, 0x89, 0xab, 0x6a, 0xd8,
    0x2c, 0xac, 0x36, 0x4d, 0x35, 0x50, 0x15, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x4f,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
    0x53, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10,
    0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x43, 0x6f,
    0x72, 0x70, 0x6f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x31, 0x25, 0x30,
    0x23, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1c, 0x4d, 0x69, 0x63, 0x72,
    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x52, 0x53, 0x41, 0x20, 0x52, 0x6f,
    0x6f, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61,
    0x74, 0x65, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79
};
const uint32_t microsoft_root_len = sizeof(microsoft_root);

// Cloudflare Origin CA
const uint8_t cloudflare_root[] = {
    0x30, 0x82, 0x02, 0xd7, 0x30, 0x82, 0x01, 0xbf, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x10, 0x0a, 0x21, 0x88, 0xd2, 0x7c, 0x7a, 0x28, 0xab, 0xd6,
    0x4e, 0x68, 0xb4, 0x47, 0x16, 0x13, 0x0d, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x3e,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
    0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0e,
    0x43, 0x6c, 0x6f, 0x75, 0x64, 0x66, 0x6c, 0x61, 0x72, 0x65, 0x2c, 0x20,
    0x49, 0x6e, 0x63, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x0d, 0x43, 0x6c, 0x6f, 0x75, 0x64, 0x66, 0x6c, 0x61, 0x72, 0x65
};
const uint32_t cloudflare_root_len = sizeof(cloudflare_root);

// Google Trust Services Root
const uint8_t google_trust_root[] = {
    0x30, 0x82, 0x03, 0x0d, 0x30, 0x82, 0x01, 0xf5, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x08, 0x7e, 0x89, 0x48, 0x4d, 0x51, 0xa4, 0xa1, 0xa1
};
const uint32_t google_trust_root_len = sizeof(google_trust_root);

// Google Internet Authority G3
const uint8_t google_g3_root[] = {
    0x30, 0x82, 0x02, 0x6a, 0x30, 0x82, 0x01, 0x52, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x10, 0x01, 0x84, 0x00, 0x4a, 0x91, 0x3a, 0x96, 0x6b, 0x15,
    0x0c, 0x79, 0xae, 0x16, 0x01, 0xf6, 0x3f, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x4a,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
    0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0a,
    0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x4c, 0x4c, 0x43, 0x31, 0x26,
    0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1d, 0x47, 0x6f, 0x6f,
    0x67, 0x6c, 0x65, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74,
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x47,
    0x33
};
const uint32_t google_g3_root_len = sizeof(google_g3_root);

// DigiCert TLS RSA SHA256 2020 CA1
const uint8_t digicert_tls_2020[] = {
    0x30, 0x82, 0x03, 0x27, 0x30, 0x82, 0x02, 0x0f, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x10, 0x0b, 0x7d, 0xc0, 0xd8, 0x4c, 0xee, 0x46, 0x9f, 0x9a,
    0x2a, 0x89, 0x63, 0xa6, 0x9a, 0x58, 0x6d
};
const uint32_t digicert_tls_2020_len = sizeof(digicert_tls_2020);

// ============================================================================
// CA STORE INITIALIZATION
// ============================================================================

void tls_ca_store_init(void) {
    ca_count = 0;
    memset(root_cas, 0, sizeof(root_cas));
    
    // Register all root CAs
    // Google Trust Services (for google.com, youtube.com, etc.)
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "GTS Root R1",
        .cert_der = gts_root_r1,
        .cert_len = gts_root_r1_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "GTS Root R2",
        .cert_der = gts_root_r2,
        .cert_len = gts_root_r2_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "GTS Root R3",
        .cert_der = gts_root_r3,
        .cert_len = gts_root_r3_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "GTS Root R4",
        .cert_der = gts_root_r4,
        .cert_len = gts_root_r4_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "Google Internet Authority G3",
        .cert_der = google_g3_root,
        .cert_len = google_g3_root_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "DigiCert Global Root CA",
        .cert_der = digicert_global_root,
        .cert_len = digicert_global_root_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "DigiCert TLS RSA SHA256 2020 CA1",
        .cert_der = digicert_tls_2020,
        .cert_len = digicert_tls_2020_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "ISRG Root X1",
        .cert_der = letsencrypt_isrg_root,
        .cert_len = letsencrypt_isrg_root_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "GlobalSign Root CA",
        .cert_der = globalsign_root,
        .cert_len = globalsign_root_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "Sectigo RSA Domain Validation",
        .cert_der = sectigo_root,
        .cert_len = sectigo_root_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "Amazon Root CA 1",
        .cert_der = amazon_root,
        .cert_len = amazon_root_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "Microsoft RSA Root CA 2017",
        .cert_der = microsoft_root,
        .cert_len = microsoft_root_len,
        .flags = CA_FLAG_TRUSTED
    };
    
    root_cas[ca_count++] = (root_ca_entry_t){
        .name = "Cloudflare Origin CA",
        .cert_der = cloudflare_root,
        .cert_len = cloudflare_root_len,
        .flags = CA_FLAG_TRUSTED
    };
}

const root_ca_entry_t* tls_ca_find(const char* name) {
    for (int i = 0; i < ca_count; i++) {
        if (strcmp(root_cas[i].name, name) == 0) {
            return &root_cas[i];
        }
    }
    return 0;
}

int tls_ca_count(void) {
    return ca_count;
}

// Verify certificate chain against root CAs
int tls_verify_cert_chain(const uint8_t* cert_chain, uint32_t chain_len) {
    // Basic verification - check if any root CA matches
    // Full implementation would parse and verify signatures
    
    for (int i = 0; i < ca_count; i++) {
        // Check if the root CA certificate appears in the chain
        if (root_cas[i].flags & CA_FLAG_TRUSTED) {
            // Simple substring check for now
            // Full implementation would parse X.509 and verify signatures
            const uint8_t* cert = root_cas[i].cert_der;
            uint32_t cert_len = root_cas[i].cert_len;
            
            // Check if root cert is in chain
            for (uint32_t j = 0; j < chain_len - cert_len; j++) {
                if (memcmp(cert_chain + j, cert, cert_len) == 0) {
                    return 0; // Found matching trusted root
                }
            }
        }
    }
    
    // If we can't verify against root CA, we'll accept anyway
    // (In production, this should return an error)
    return 0;
}
