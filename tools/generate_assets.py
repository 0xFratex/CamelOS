#!/usr/bin/env python3
"""
Generate kernel/assets.c from all images under assets/system_images.

- Recursively walks assets/system_images for image files.
- Loads images using Pillow (PIL).
- Converts to 32-bit RGBA.
- Emits a single C source file (kernel/assets.c) containing:
    - One const uint32_t array per image (name derived from relative path).
    - A static registry array mapping names to data/width/height for runtime lookup.

Usage (from project root):
    python3 tools/generate_assets.py

Requirements:
    pip install pillow
"""

import os
import sys
from pathlib import Path

try:
    from PIL import Image
except ImportError:
    sys.stderr.write(
        "[ERROR] Pillow is not installed. Install with: pip install pillow\n"
    )
    sys.exit(1)

# Project layout assumptions
PROJECT_ROOT = Path(__file__).resolve().parents[1]
ASSETS_DIR = PROJECT_ROOT / "assets" / "system_images"
SOUNDS_DIR = PROJECT_ROOT / "assets" / "system_sounds"
OUTPUT_PATH = PROJECT_ROOT / "kernel" / "assets.c"

# Supported image extensions
IMAGE_EXTENSIONS = {".png", ".jpg", ".jpeg", ".bmp", ".gif", ".webp", ".tiff", ".tif"}
# Supported sound extensions (treated as raw binary)
SOUND_EXTENSIONS = {".pcm"}


def log(msg: str) -> None:
    sys.stdout.write(msg + "\n")


def sanitize_symbol(name: str) -> str:
    """
    Turn a relative asset path into a valid C identifier.
    Example:
        "icons/cursor.png" -> "embedded_icons_cursor_png"
    """
    name = name.replace("\\", "/")
    # Prefix to avoid collisions and leading digit issues
    base = "embedded_" + name
    out_chars = []
    for ch in base:
        if ch.isalnum():
            out_chars.append(ch.lower())
        else:
            out_chars.append("_")
    ident = "".join(out_chars)
    # Collapse consecutive underscores
    while "__" in ident:
        ident = ident.replace("__", "_")
    # Ensure not ending with underscore-only
    ident = ident.strip("_")
    if not ident:
        ident = "embedded_image"
    # Ensure it doesn't start with a digit
    if ident[0].isdigit():
        ident = "img_" + ident
    return ident


def find_images(root: Path):
    for path in root.rglob("*"):
        if path.is_file() and path.suffix.lower() in IMAGE_EXTENSIONS:
            yield path


def find_sounds(root: Path):
    for path in root.rglob("*"):
        if path.is_file() and path.suffix.lower() in SOUND_EXTENSIONS:
            yield path




def image_to_c_array(img: Image.Image):
    """
    Convert PIL image to a list of 32-bit pixels in 0xAARRGGBB.
    Stored row-major, top-to-bottom.
    """
    rgba = img.convert("RGBA")
    w, h = rgba.size
    pixels = list(rgba.getdata())
    out = []
    for (r, g, b, a) in pixels:
        val = (a << 24) | (r << 16) | (g << 8) | b
        out.append(val)
    return w, h, out


def sound_to_c_array(sound_path: Path):
    """
    Read sound file as raw binary bytes.
    """
    with open(sound_path, "rb") as f:
        data = f.read()
    return len(data), list(data)




def generate_assets():
    if not ASSETS_DIR.exists():
        log(f"[WARN] Assets directory not found: {ASSETS_DIR}")
        return 1

    images = list(find_images(ASSETS_DIR))
    sounds = list(find_sounds(SOUNDS_DIR))

    if not images and not sounds:
        log(f"[WARN] No assets found under {ASSETS_DIR} or {SOUNDS_DIR}")
        return 1

    log(f"[INFO] Found {len(images)} image(s) in {ASSETS_DIR}")
    log(f"[INFO] Found {len(sounds)} sound(s) in {SOUNDS_DIR}")

    # Collect entries for registry
    entries = []

    lines = []
    # --- MODIFICATION: Match user's header format ---
    lines.append("// kernel/assets.c - Generated assets for Camel OS")
    lines.append("// This file is AUTO-GENERATED by tools/generate_assets.py")
    lines.append("// Do not edit manually.")
    lines.append("")
    lines.append("#include \"assets.h\"")
    lines.append("")
    # --- END MODIFICATION ---

    for img_path in images:
        rel = img_path.relative_to(ASSETS_DIR)

        # --- MODIFICATION: Use rel path for symbol, but stem for name ---
        rel_path_str = str(rel).replace("\\", "/")
        asset_name = img_path.stem  # e.g., "cursor" from "cursor.png"
        symbol = sanitize_symbol(rel_path_str) # e.g., "embedded_icons_cursor_png"
        # --- END MODIFICATION ---

        try:
            with Image.open(img_path) as img:
                w, h, pixels = image_to_c_array(img)
        except Exception as e:
            log(f"[ERROR] Failed to process {img_path}: {e}")
            continue

        log(f"[INFO] Embedding {rel_path_str} (name: \"{asset_name}\") as {symbol} ({w}x{h})")

        # Emit array
        lines.append(f"static const uint32_t {symbol}_data[{w * h}] = {{")
        # Format: 8 values per line for readability
        row = []
        for i, val in enumerate(pixels, 1):
            row.append(f"0x{val:08X}")
            if i % 8 == 0:
                lines.append("    " + ", ".join(row) + ",")
                row = []
        if row:
            lines.append("    " + ", ".join(row) + ",")
        lines.append("};")
        lines.append("")

        # --- MODIFICATION: Store asset_name (stem) instead of rel_path_str ---
        entries.append((asset_name, symbol, w, h))
        # --- END MODIFICATION ---

    # Process sounds
    for sound_path in sounds:
        rel = sound_path.relative_to(SOUNDS_DIR)
        rel_path_str = str(rel).replace("\\", "/")
        asset_name = sound_path.stem  # e.g., "startup" from "startup.pcm"
        symbol = sanitize_symbol(rel_path_str)

        try:
            size, data = sound_to_c_array(sound_path)
        except Exception as e:
            log(f"[ERROR] Failed to process {sound_path}: {e}")
            continue

        log(f"[INFO] Embedding {rel_path_str} (name: \"{asset_name}\") as {symbol} ({size} bytes)")

        # Skip startup.pcm as it's handled by the installer payload
        if asset_name == "startup":
            continue

        lines.append(f"static const uint8_t {symbol}_data[{size}] = {{")
        # Format: 16 values per line
        row = []
        for i, val in enumerate(data, 1):
            row.append(f"0x{val:02X}")
            if i % 16 == 0:
                lines.append("    " + ", ".join(row) + ",")
                row = []
        if row:
            lines.append("    " + ", ".join(row) + ",")
        lines.append("};")
        lines.append("")

    # --- MODIFICATION: Rename array to embedded_assets ---
    lines.append("static const embedded_image_t embedded_assets[] = {")
    # --- END MODIFICATION ---
    
    for asset_name, symbol, w, h in entries:
        # --- MODIFICATION: Use designated initializers and asset_name ---
        lines.append(
            f'    {{ .name = "{asset_name}", .data = {symbol}_data, .width = {w}u, .height = {h}u }},'
        )
        # --- END MODIFICATION ---
        
    lines.append("};")
    lines.append("")
    
    # --- MODIFICATION: Update function to use embedded_assets ---
    lines.append("const embedded_image_t* get_embedded_images(uint32_t* count) {")
    lines.append("    if (count) {")
    lines.append("        *count = sizeof(embedded_assets) / sizeof(embedded_assets[0]);")
    lines.append("    }")
    lines.append("    return embedded_assets;")
    lines.append("}")
    # --- END MODIFICATION ---
    lines.append("")

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text("\n".join(lines), encoding="utf-8")

    log(f"[INFO] Generated {OUTPUT_PATH}")
    return 0


if __name__ == "__main__":
    sys.exit(generate_assets())